// @flow

type Exclude<A, B> = A;
// see https://gist.github.com/thecotne/6e5969f4aaf8f253985ed36b30ac9fe0
type $FlowGen$If<X: boolean, Then, Else = empty> = $Call<
  ((true, Then, Else) => Then) & ((false, Then, Else) => Else),
  X,
  Then,
  Else
>;

type $FlowGen$Assignable<A, B> = $Call<
  ((...r: [B]) => true) & ((...r: [A]) => false),
  A
>;

import type {
  Angle,
  CssColor,
  Rule,
  CustomProperty,
  EnvironmentVariable,
  Function,
  Image,
  LengthValue,
  MediaQuery,
  Declaration,
  Ratio,
  Resolution,
  Selector,
  SupportsCondition,
  Time,
  Token,
  TokenOrValue,
  UnknownAtRule,
  Url,
  Variable,
} from "./ast.js.flow";
import type { Targets } from "./targets.js.flow";
declare export * from "./ast.js.flow";
export type TransformOptions = {|
  /**
   * The filename being transformed. Used for error messages and source maps.
   */
  filename: string,

  /**
   * The source code to transform.
   */
  code: Buffer,

  /**
   * Whether to enable minification.
   */
  minify?: boolean,

  /**
   * Whether to output a source map.
   */
  sourceMap?: boolean,

  /**
   * An input source map to extend.
   */
  inputSourceMap?: string,

  /**
   * An optional project root path, used as the source root in the output source map.
   * Also used to generate relative paths for sources used in CSS module hashes.
   */
  projectRoot?: string,

  /**
   * The browser targets for the generated code.
   */
  targets?: Targets,

  /**
   * Whether to enable various draft syntax.
   */
  drafts?: Drafts,

  /**
   * Whether to compile this file as a CSS module.
   */
  cssModules?: boolean | CSSModulesConfig,

  /**
   * Whether to analyze dependencies (e.g. `@import` and `url()`).
   * When enabled, `@import` rules are removed, and `url()` dependencies
   * are replaced with hashed placeholders that can be replaced with the final
   * urls later (after bundling). Dependencies are returned as part of the result.
   */
  analyzeDependencies?: boolean | DependencyOptions,

  /**
   * Replaces user action pseudo classes with class names that can be applied from JavaScript.
   * This is useful for polyfills, for example.
   */
  pseudoClasses?: PseudoClasses,

  /**
   * A list of class names, ids, and custom identifiers (e.g. @keyframes) that are known
   * to be unused. These will be removed during minification. Note that these are not
   * selectors but individual names (without any . or # prefixes).
   */
  unusedSymbols?: string[],

  /**
   * Whether to ignore invalid rules and declarations rather than erroring.
   * When enabled, warnings are returned, and the invalid rule or declaration is
   * omitted from the output code.
   */
  errorRecovery?: boolean,

  /**
   * An AST visitor object. This allows custom transforms or analysis to be implemented in JavaScript.
   * Multiple visitors can be composed into one using the `composeVisitors` function.
   * For optimal performance, visitors should be as specific as possible about what types of values
   * they care about so that JavaScript has to be called as little as possible.
   */
  visitor?: Visitor,
|};
declare type FindByType<Union, Name> = $FlowGen$If<
  $FlowGen$Assignable<
    Union,
    {|
      type: Name,
    |}
  >,
  Union,
  empty
>;
declare type RuleVisitor<R = Rule> = (rule: R) => Rule | Rule[] | void;
declare type MappedRuleVisitors = $ObjMapi<
  { [k: Exclude<$PropertyType<Rule, "type">, "unknown" | "custom">]: any },
  <Name>(Name) => RuleVisitor<FindByType<Rule, Name>>
>;
declare type UnknownVisitors = {
  [name: string]: RuleVisitor<UnknownAtRule>,
};
declare type RuleVisitors = {|
  ...MappedRuleVisitors,
  ...{|
    unknown?: UnknownVisitors | RuleVisitor<UnknownAtRule>,
  |},
|};
declare type FindProperty<Union, Name> = $FlowGen$If<
  $FlowGen$Assignable<
    Union,
    {|
      property: Name,
    |}
  >,
  Union,
  empty
>;
declare type DeclarationVisitor<P = Declaration> = (
  property: P
) => Declaration | Declaration[] | void;
declare type MappedDeclarationVisitors = $ObjMapi<
  {
    [k: Exclude<
      $PropertyType<Declaration, "property">,
      "unparsed" | "custom"
    >]: any,
  },
  <Name>(
    Name
  ) => DeclarationVisitor<
    FindProperty<Declaration, Name> | FindProperty<Declaration, "unparsed">
  >
>;
declare type CustomPropertyVisitors = {
  [name: string]: DeclarationVisitor<CustomProperty>,
};
declare type DeclarationVisitors = {|
  ...MappedDeclarationVisitors,
  ...{|
    custom?: CustomPropertyVisitors | DeclarationVisitor<CustomProperty>,
  |},
|};
declare type TokenVisitor = (
  token: Token
) => TokenOrValue | TokenOrValue[] | void;
declare type VisitableTokenTypes =
  | "ident"
  | "at-keyword"
  | "hash"
  | "id-hash"
  | "string"
  | "number"
  | "percentage"
  | "dimension";
declare type TokenVisitors = $ObjMapi<
  { [k: VisitableTokenTypes]: any },
  <Name>(
    Name
  ) => (token: FindByType<Token, Name>) => TokenOrValue | TokenOrValue[] | void
>;
declare type FunctionVisitor = (
  fn: Function
) => TokenOrValue | TokenOrValue[] | void;
declare type EnvironmentVariableVisitor = (
  env: EnvironmentVariable
) => TokenOrValue | TokenOrValue[] | void;
declare type EnvironmentVariableVisitors = {
  [name: string]: EnvironmentVariableVisitor,
};
export type Visitor = {|
  Rule?: RuleVisitor<> | RuleVisitors,
  RuleExit?: RuleVisitor<> | RuleVisitors,
  Declaration?: DeclarationVisitor<> | DeclarationVisitors,
  DeclarationExit?: DeclarationVisitor<> | DeclarationVisitors,
  Url?: (url: Url) => Url | void,
  Color?: (color: CssColor) => CssColor | void,
  Image?: (image: Image) => Image | void,
  ImageExit?: (image: Image) => Image | void,
  Length?: (length: LengthValue) => LengthValue | void,
  Angle?: (angle: Angle) => Angle | void,
  Ratio?: (ratio: Ratio) => Ratio | void,
  Resolution?: (resolution: Resolution) => Resolution | void,
  Time?: (time: Time) => Time | void,
  CustomIdent?: (ident: string) => string | void,
  DashedIdent?: (ident: string) => string | void,
  MediaQuery?: (query: MediaQuery) => MediaQuery | MediaQuery[] | void,
  MediaQueryExit?: (query: MediaQuery) => MediaQuery | MediaQuery[] | void,
  SupportsCondition?: (condition: SupportsCondition) => SupportsCondition,
  SupportsConditionExit?: (condition: SupportsCondition) => SupportsCondition,
  Selector?: (selector: Selector) => Selector | Selector[] | void,
  Token?: TokenVisitor | TokenVisitors,
  Function?:
    | FunctionVisitor
    | {
        [name: string]: FunctionVisitor,
      },
  FunctionExit?:
    | FunctionVisitor
    | {
        [name: string]: FunctionVisitor,
      },
  Variable?: (variable: Variable) => TokenOrValue | TokenOrValue[] | void,
  VariableExit?: (variable: Variable) => TokenOrValue | TokenOrValue[] | void,
  EnvironmentVariable?:
    | EnvironmentVariableVisitor
    | EnvironmentVariableVisitors,
  EnvironmentVariableExit?:
    | EnvironmentVariableVisitor
    | EnvironmentVariableVisitors,
|};
export type DependencyOptions = {|
  /**
   * Whether to preserve `@import` rules rather than removing them.
   */
  preserveImports?: boolean,
|};
export type BundleOptions = $Diff<TransformOptions, {| code: any |}>;
export type BundleAsyncOptions = {|
  ...$Exact<BundleOptions>,

  resolver?: Resolver,
|};

/**
 * Custom resolver to use when loading CSS files.
 */
export type Resolver = {|
  /**
   * Read the given file and return its contents as a string.
   */
  read?: (file: string) => string | Promise<string>,

  /**
   * Resolve the given CSS import specifier from the provided originating file to a
   * path which gets passed to `read()`.
   */
  resolve?: (
    specifier: string,
    originatingFile: string
  ) => string | Promise<string>,
|};
export type Drafts = {|
  /**
   * Whether to enable CSS nesting.
   */
  nesting?: boolean,

  /**
   * Whether to enable @custom-media rules.
   */
  customMedia?: boolean,
|};
export type PseudoClasses = {|
  hover?: string,
  active?: string,
  focus?: string,
  focusVisible?: string,
  focusWithin?: string,
|};
export type TransformResult = {|
  /**
   * The transformed code.
   */
  code: Buffer,

  /**
   * The generated source map, if enabled.
   */
  map: Buffer | void,

  /**
   * CSS module exports, if enabled.
   */
  exports: CSSModuleExports | void,

  /**
   * CSS module references, if `dashedIdents` is enabled.
   */
  references: CSSModuleReferences,

  /**
   * `@import` and `url()` dependencies, if enabled.
   */
  dependencies: Dependency[] | void,

  /**
   * Warnings that occurred during compilation.
   */
  warnings: Warning[],
|};
export type Warning = {|
  message: string,
  type: string,
  value?: any,
  loc: ErrorLocation,
|};
export type CSSModulesConfig = {|
  /**
   * The pattern to use when renaming class names and other identifiers. Default is `[hash]_[local]`.
   */
  pattern: string,

  /**
   * Whether to rename dashed identifiers, e.g. custom properties.
   */
  dashedIdents: boolean,
|};
export type CSSModuleExports = {
  /**
   * Maps exported (i.e. original) names to local names.
   */
  [name: string]: CSSModuleExport,
};
export type CSSModuleExport = {|
  /**
   * The local (compiled) name for this export.
   */
  name: string,

  /**
   * Whether the export is referenced in this file.
   */
  isReferenced: boolean,

  /**
   * Other names that are composed by this export.
   */
  composes: CSSModuleReference[],
|};
export type CSSModuleReferences = {
  /**
   * Maps placeholder names to references.
   */
  [name: string]: DependencyCSSModuleReference,
};
export type CSSModuleReference =
  | LocalCSSModuleReference
  | GlobalCSSModuleReference
  | DependencyCSSModuleReference;
export type LocalCSSModuleReference = {|
  type: "local",

  /**
   * The local (compiled) name for the reference.
   */
  name: string,
|};
export type GlobalCSSModuleReference = {|
  type: "global",

  /**
   * The referenced global name.
   */
  name: string,
|};
export type DependencyCSSModuleReference = {|
  type: "dependency",

  /**
   * The name to reference within the dependency.
   */
  name: string,

  /**
   * The dependency specifier for the referenced file.
   */
  specifier: string,
|};
export type Dependency = ImportDependency | UrlDependency;
export type ImportDependency = {|
  type: "import",

  /**
   * The url of the `@import` dependency.
   */
  url: string,

  /**
   * The media query for the `@import` rule.
   */
  media: string | null,

  /**
   * The `supports()` query for the `@import` rule.
   */
  supports: string | null,

  /**
   * The source location where the `@import` rule was found.
   */
  loc: SourceLocation,
|};
export type UrlDependency = {|
  type: "url",

  /**
   * The url of the dependency.
   */
  url: string,

  /**
   * The source location where the `url()` was found.
   */
  loc: SourceLocation,

  /**
   * The placeholder that the url was replaced with.
   */
  placeholder: string,
|};
export type SourceLocation = {|
  /**
   * The file path in which the dependency exists.
   */
  filePath: string,

  /**
   * The start location of the dependency.
   */
  start: Location,

  /**
   * The end location (inclusive) of the dependency.
   */
  end: Location,
|};
export type Location = {|
  /**
   * The line number (1-based).
   */
  line: number,

  /**
   * The column number (0-based).
   */
  column: number,
|};
export type ErrorLocation = {|
  ...$Exact<Location>,

  filename: string,
|};

/**
 * Compiles a CSS file, including optionally minifying and lowering syntax to the given
 * targets. A source map may also be generated, but this is not enabled by default.
 */
declare export function transform(options: TransformOptions): TransformResult;
export type TransformAttributeOptions = {|
  /**
   * The filename in which the style attribute appeared. Used for error messages and dependencies.
   */
  filename?: string,

  /**
   * The source code to transform.
   */
  code: Buffer,

  /**
   * Whether to enable minification.
   */
  minify?: boolean,

  /**
   * The browser targets for the generated code.
   */
  targets?: Targets,

  /**
   * Whether to analyze `url()` dependencies.
   * When enabled, `url()` dependencies are replaced with hashed placeholders
   * that can be replaced with the final urls later (after bundling).
   * Dependencies are returned as part of the result.
   */
  analyzeDependencies?: boolean,

  /**
   * Whether to ignore invalid rules and declarations rather than erroring.
   * When enabled, warnings are returned, and the invalid rule or declaration is
   * omitted from the output code.
   */
  errorRecovery?: boolean,

  /**
   * An AST visitor object. This allows custom transforms or analysis to be implemented in JavaScript.
   * Multiple visitors can be composed into one using the `composeVisitors` function.
   * For optimal performance, visitors should be as specific as possible about what types of values
   * they care about so that JavaScript has to be called as little as possible.
   */
  visitor?: Visitor,
|};
export type TransformAttributeResult = {|
  /**
   * The transformed code.
   */
  code: Buffer,

  /**
   * `@import` and `url()` dependencies, if enabled.
   */
  dependencies: Dependency[] | void,

  /**
   * Warnings that occurred during compilation.
   */
  warnings: Warning[],
|};

/**
 * Compiles a single CSS declaration list, such as an inline style attribute in HTML.
 */
declare export function transformStyleAttribute(
  options: TransformAttributeOptions
): TransformAttributeResult;

/**
 * Converts a browserslist result into targets that can be passed to lightningcss.
 * @param browserslist the result of calling `browserslist`
 */
declare export function browserslistToTargets(browserslist: string[]): Targets;

/**
 * Bundles a CSS file and its dependencies, inlining @import rules.
 */
declare export function bundle(options: BundleOptions): TransformResult;

/**
 * Bundles a CSS file and its dependencies asynchronously, inlining @import rules.
 */
declare export function bundleAsync(
  options: BundleAsyncOptions
): Promise<TransformResult>;

/**
 * Composes multiple visitor objects into a single one.
 */
declare export function composeVisitors(visitors: Visitor[]): Visitor;
